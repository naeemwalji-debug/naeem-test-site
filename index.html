<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio Header</title>

  <!-- Preload Unicorn Studio for faster loading -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="preload" href="https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v2.0.4/dist/unicornStudio.umd.js" as="script">
  
  <!-- Load Unicorn Studio script early in head -->
  <script src="https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v2.0.4/dist/unicornStudio.umd.js"></script>

  <!-- Google Font: Zalando Sans Expanded -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Zalando+Sans+Expanded:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">

  <!-- Adobe Fonts: Selfie Neue Round -->
  <link rel="stylesheet" href="https://use.typekit.net/ijw2rnp.css">

  <style>
    :root{
      --cornerInset: 25px;   /* distance from edges */
      --plusSize: 30px;      /* your + size */
      --navClearance: 18px;  /* extra breathing room from the rotating + */
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { overflow-y: scroll; }
    body { background: #000; overflow-x: hidden; }
    
    /* Pages container */
    #pagesWrapper {
      position: relative;
      background: #fff;
    }

    /* About Section */
    #about {
      position: relative;
      width: 100%;
      height: 100vh;
      background: #fff;
      z-index: 10;
      box-shadow: 0 -20px 60px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      padding: 0 55px; /* Add padding for margins */
      box-sizing: border-box;
    }
    .about-container {
      position: relative;
      overflow: visible;
      max-width: 1164px;
      width: 100%;
    }
    .about-title {
      position: absolute;
      left: -40px; /* Compensate for the 40px padding to align visually */
      bottom: calc(100% - 27px); /* Base overlap for small screens */
      color: #797979;
      font-family: "selfie-neue-round", "Brush Script MT", cursive;
      font-weight: 700;
      font-size: clamp(80px, 12vw, 160px); /* Responsive font size */
      line-height: 0.9;
      word-wrap: break-word;
      z-index: 1;
      white-space: nowrap;
      overflow: visible;
      padding: 20px 40px;
      margin: -20px -40px;
    }
    .about-body {
      position: relative;
      width: 100%;
      max-width: 1164px;
      color: #000;
      font-family: "Zalando Sans Expanded", sans-serif;
      font-weight: 700;
      font-size: clamp(20px, 3vw, 36px); /* Responsive font size */
      line-height: 1.03;
      text-transform: uppercase;
      word-wrap: break-word;
      z-index: 2;
    }
    .about-body p { margin: 0; }
    .about-body p + p { margin-top: 1em; }

    /* Work Section */
    #work {
      position: relative;
      width: 100%;
      min-height: 100vh;
      background: #000;
      z-index: 20;
      box-shadow: 0 -20px 60px rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-sizing: border-box;
    }
    .work-container {
      position: relative;
      overflow: visible;
      width: 100%;
      max-width: 1200px;
      padding: 0 55px;
      box-sizing: border-box;
    }
    .work-title {
      position: absolute;
      left: 15px;
      bottom: calc(100% - 23px); /* Base overlap for small screens */
      color: #797979;
      font-family: "selfie-neue-round", "Brush Script MT", cursive;
      font-weight: 700;
      font-size: clamp(80px, 12vw, 160px);
      line-height: 0.9;
      word-wrap: break-word;
      z-index: 1;
      white-space: nowrap;
      overflow: visible;
      padding: 20px 40px;
      margin: -20px -40px;
    }
    .work-grid {
      position: relative;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0;
      width: 100%;
      z-index: 2;
    }
    .work-item {
      aspect-ratio: 16 / 9;
    }
    
    /* Responsive Work grid */
    @media (max-width: 768px) {
      .work-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    /* Increase title overlap on larger screens */
    @media (min-width: 1024px) {
      .about-title {
        bottom: calc(100% - 52px);
      }
      .work-title {
        bottom: calc(100% - 50px);
      }
    }
    
    /* Spacer */
    #headerSpacer {
      height: 100vh;
      width: 100%;
    }

    #header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: #000;
      overflow: hidden;
      z-index: 1;
    }

    .cornerMarks {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: difference;
    }
    .cornerMarks line {
      stroke: #fff;
      stroke-width: 1;
      shape-rendering: crispEdges;
      vector-effect: non-scaling-stroke;
    }

    .site-nav{
      position: fixed;
      left: 55px;
      top: 55px;
      z-index: 9999;
      mix-blend-mode: difference;

      display: flex;
      flex-direction: column;

      font-family: "Zalando Sans Expanded", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 700;

      font-size: 14.67px;
      line-height: 16px;
      letter-spacing: 2px;

      text-transform: uppercase;
    }
    
    /* Margin guides - temporary pink lines */
    .margin-guide {
      position: fixed;
      top: 0;
      bottom: 0;
      width: 1px;
      background: pink;
      z-index: 99999;
      pointer-events: none;
    }
    .margin-guide-left {
      left: 55px;
    }
    .margin-guide-right {
      right: 55px;
    }
    
    .site-nav a {
      position: relative;
      display: block;
    }
    
    .nav-text {
      position: relative;
      z-index: 1;
    }
    
    .nav-indicator {
      position: absolute;
      left: -1px;
      top: -1px;
      bottom: -1px;
      background: #fff;
      pointer-events: none;
      z-index: 0;
      width: 0;
    }

    .site-nav a{
      color: rgba(255,255,255,0.95);
      text-decoration: none;
      display: block;
      padding: 0;
      user-select: none;
    }

    .site-nav a:hover{
      color: #fff;
    }

    /* === Names === */
    .name {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 0;

      font-family: "Zalando Sans Expanded", sans-serif;
      font-optical-sizing: auto;
      font-weight: 700;
      font-style: normal;

      font-size: clamp(22px, 3vw, 40px);
      letter-spacing: 0.40em;
      color: #ffffff;
      text-transform: uppercase;
      opacity: 0.95;
      white-space: nowrap;
    }
    
    .name .letter {
      display: inline-block;
      opacity: 0;
      animation: letterFadeIn 0.9s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      animation-delay: calc(var(--delay) * 0.2s + 0.3s);
      will-change: opacity, transform;
      backface-visibility: hidden;
    }
    
    @keyframes letterFadeIn {
      0% {
        opacity: 0;
        transform: translateY(8px) translateZ(0);
      }
      100% {
        opacity: 1;
        transform: translateY(0) translateZ(0);
      }
    }

    #descriptor{
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      z-index: 0; /* under the trail canvas (trail is z-index: 1) */

      font-family: "Zalando Sans Expanded", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 400; /* Regular */
      font-size: 20px;
      letter-spacing: 2px; /* ≈ 20 tracking */
      text-transform: uppercase;

      color: rgba(255,255,255,0.9);
      pointer-events: none;
      
      /* Fade in descriptor after names */
      opacity: 0;
      animation: fadeIn 0.8s ease forwards;
      animation-delay: 1.8s;
    }
    
    @keyframes fadeIn {
      to { opacity: 0.9; }
    }

    #downArrow{
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: difference;
    }

    #downArrow line{
      stroke: #fff;
      stroke-width: 1;
      shape-rendering: crispEdges;
      vector-effect: non-scaling-stroke;
    }
    
    .copyright {
      position: fixed;
      right: 55px;
      bottom: 55px;
      z-index: 9999;
      mix-blend-mode: difference;
      
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      
      font-family: "Zalando Sans Expanded", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 700;
      font-size: 11px; /* 14.67 * 0.75 = 11 */
      line-height: 12px; /* 16 * 0.75 = 12 */
      letter-spacing: 1.5px; /* 2 * 0.75 = 1.5 */
      color: #fff;
    }
    
    .copyright-logo {
      margin-top: 1.5px; /* 2 * 0.75 = 1.5 */
    }
  </style>
</head>
<body>
  <div id="header">
    <div id="unicorn-wrapper" style="position: absolute; inset: 0; width: 100%; height: 100%; opacity: 0; transition: opacity 0.6s ease;">
      <div data-us-project="IBucRrDfjuXD6saiKULP" style="width: 100%; height: 100%;"></div>
    </div>

    <!-- Names with individual letters for animation -->
    <div id="nameLeft" class="name">
      <span class="letter" style="--delay: 0">N</span>
      <span class="letter" style="--delay: 1">A</span>
      <span class="letter" style="--delay: 2">E</span>
      <span class="letter" style="--delay: 3">E</span>
      <span class="letter" style="--delay: 4">M</span>
    </div>
    <div id="nameRight" class="name">
      <span class="letter" style="--delay: 4">W</span>
      <span class="letter" style="--delay: 3">A</span>
      <span class="letter" style="--delay: 2">L</span>
      <span class="letter" style="--delay: 1">J</span>
      <span class="letter" style="--delay: 0">I</span>
    </div>
    <div id="descriptor">FREELANCE CREATIVE / ART DIRECTOR</div>
  </div>

  <!-- Fixed UI elements - OUTSIDE header so not clipped -->
  <svg id="cornerMarks" class="cornerMarks">
    <g id="plusTL"><line/><line/></g>
    <g id="plusTR"><line/><line/></g>
    <g id="plusBL"><line/><line/></g>
    <g id="plusBR"><line/><line/></g>
  </svg>

  <svg id="downArrow" viewBox="0 0 40 20">
    <line id="arrowLeft"/>
    <line id="arrowRight"/>
  </svg>

  <nav class="site-nav" aria-label="Primary">
    <a href="#header" id="navHome"><span class="nav-indicator"></span><span class="nav-text">HOME</span></a>
    <a href="#about" id="navAbout"><span class="nav-indicator"></span><span class="nav-text">ABOUT ME</span></a>
    <a href="#work" id="navWork"><span class="nav-indicator"></span><span class="nav-text">WORK</span></a>
    <a href="#contact" id="navContact"><span class="nav-indicator"></span><span class="nav-text">CONTACT</span></a>
  </nav>

  <!-- Temporary margin guides -->
  <div class="margin-guide margin-guide-left"></div>
  <div class="margin-guide margin-guide-right"></div>

  <div class="copyright">
    <span>©</span>
    <span>2026</span>
    <svg class="copyright-logo" viewBox="0 0 231.15 124.56" xmlns="http://www.w3.org/2000/svg">
      <path 
        fill="#fff"
        d="M38.66,0C17.7,0,0,16.72,0,36.5c0,16.47,12.7,29.86,28.32,29.86,14.08,0,25.54-10.49,25.54-23.38,0-3.72-.78-7.15-2.13-9.41-1.93-3.36-5.18-5.31-8.9-5.31-1.63,0-3.23.39-4.63,1.14-4.1,2.17-5.64,6.72-3.65,10.82.13.25.49,1.06.49,1.99,0,3.19-3.08,5.79-6.87,5.79-5.24,0-9.5-5.02-9.5-11.2,0-9.92,9.16-18.3,19.99-18.3,12.43,0,20.46,8.33,20.46,21.23,0,5.8-1.9,13.1-5.49,21.1l-22.07,48.15c-1.35,2.98-1.61,5.95-.73,8.61.81,2.46,2.58,4.47,4.87,5.52,1.21.55,2.5.83,3.84.83,4.1,0,7.75-2.6,9.76-6.95l24.39-53.11c5.73-12.57,11.59-18.67,17.91-18.67,2.63,0,3.48.88,3.48,3.63,0,2.56-1.07,6.4-2.85,10.27l-13.92,30.46c-1.93,4.12-3,9.12-3,14.07,0,12.7,8.81,20.91,22.45,20.91,8.25,0,15.92-3.01,22.85-8.95,3.79,5.66,10.44,8.95,18.36,8.95,15.25,0,27.52-10.55,37.5-32.26l13.07-28.41c5.73-12.57,11.59-18.67,17.91-18.67,2.47.26,3.24,1.45,3.48,3.63,0,2.56-1.07,6.4-2.85,10.26l-.02.03v.03s-.06.1-.06.1l-.02.04v.04c-2.17,5.53.8,10.2,4.84,11.95,1.31.57,2.67.85,4.03.85,3.97,0,7.7-2.47,9.52-6.29,3.07-6.29,4.76-13.05,4.76-19.01,0-12.7-8.15-20.91-20.76-20.91-6.17,0-13.01,2.26-19.24,6.37-7.12,4.69-12.95,11.47-16.87,19.62v.02s-.02.02-.02.02l-14.91,32.8c-6.42,14.13-13.2,21.59-19.6,21.59-.73,0-3.18-.11-4.12-1.58-1.06-1.64-.57-5.01,1.34-9.24l21.92-47.38c1.64-3.66,1.41-7.37-.64-10.21-1.73-2.39-4.56-3.82-7.57-3.82-.33,0-.65.02-.98.05-3.62.37-6.62,2.67-8.25,6.31l-20.67,45.05c-4.31,9.4-12.4,20.37-21,20.37-2.46-.08-5.05-1.01-5.02-3.79,0-1.34.37-2.8,1.12-4.45l14.68-31.84c3.06-6.28,4.74-13.02,4.74-18.97,0-12.7-8.15-20.91-20.76-20.91-6.07,0-11.54,1.97-16.58,5.99C74.99,13.19,59.09,0,38.66,0h0Z"
      />
    </svg>
  </div>

  <!-- Initialize Unicorn Studio -->
  <script type="text/javascript">
    let unicornRevealed = false;
    
    // Show effect on first mouse move
    function onFirstMouseMoveForUnicorn() {
      if (unicornRevealed) return;
      unicornRevealed = true;
      
      const wrapper = document.getElementById('unicorn-wrapper');
      if (wrapper) {
        wrapper.style.opacity = '1';
      }
      
      // Remove listener after first move
      document.removeEventListener('mousemove', onFirstMouseMoveForUnicorn);
    }
    
    // Listen for first mouse move
    document.addEventListener('mousemove', onFirstMouseMoveForUnicorn);
    
    // Script already loaded in head, just init
    if (window.UnicornStudio && UnicornStudio.init) {
      UnicornStudio.init().then(function(scenes) {
        console.log('Unicorn Studio loaded');
        // Effect will fade in on first mouse move, not here
      }).catch(function(err) {
        console.log('Unicorn init error:', err);
      });
    }
  </script>
  
  <script>
    const nameLeftEl = document.getElementById("nameLeft");
    const nameRightEl = document.getElementById("nameRight");

    let width, height;

    function updateNamePositions() {
      width = document.documentElement.clientWidth;
      height = document.documentElement.clientHeight;
      
      // Position names on either side of center - names are centered with transform
      // so we position them in the middle of each half
      const logoWidth = 280; // approximate logo width
      const inset = 30; // tighter to logo
      
      // Left name: center of space between left edge and logo left edge
      const logoLeftEdge = (width / 2) - (logoWidth / 2);
      const leftCenterX = (logoLeftEdge + inset) / 2;
      
      // Right name: center of space between logo right edge and right edge
      const logoRightEdge = (width / 2) + (logoWidth / 2);
      const rightCenterX = logoRightEdge - inset + (width - logoRightEdge + inset) / 2;
      
      const centerY = height / 2;

      nameLeftEl.style.left = `${leftCenterX}px`;
      nameLeftEl.style.top = `${centerY}px`;
      nameRightEl.style.left = `${rightCenterX}px`;
      nameRightEl.style.top = `${centerY}px`;

      // Update descriptor position - below the logo
      const descriptor = document.getElementById("descriptor");
      const logoBottomY = (height / 2) + 75; // approximate logo bottom
      const descriptorY = logoBottomY + (height - logoBottomY) / 2;
      descriptor.style.top = `${descriptorY}px`;
    }

    window.addEventListener('resize', updateNamePositions);
    updateNamePositions();

    // ===== Corner plus marks =====
    const cornerSvg = document.getElementById("cornerMarks");
    const plus = {
      TL: document.getElementById("plusTL"),
      TR: document.getElementById("plusTR"),
      BL: document.getElementById("plusBL"),
      BR: document.getElementById("plusBR"),
    };

    const INSET = 25;
    const HALF = 15; // total size = 30px

    let cornerMouse = { x: 0, y: 0 };
    let hasMouseMoved = false;

    window.addEventListener("mousemove", (e) => {
      cornerMouse.x = e.clientX;
      cornerMouse.y = e.clientY;
      hasMouseMoved = true;
    });

    function setPlusGeometry(g, cx, cy) {
      const lines = g.querySelectorAll("line");
      const h = lines[0];
      const v = lines[1];

      h.setAttribute("x1", cx - HALF);
      h.setAttribute("y1", cy);
      h.setAttribute("x2", cx + HALF);
      h.setAttribute("y2", cy);

      v.setAttribute("x1", cx);
      v.setAttribute("y1", cy - HALF);
      v.setAttribute("x2", cx);
      v.setAttribute("y2", cy + HALF);
    }

    function rotateAroundCenter(g, deg, cx, cy) {
      g.setAttribute("transform", `rotate(${deg} ${cx} ${cy})`);
    }

    function updateCornerMarks() {
      const w = document.documentElement.clientWidth;
      const h = window.innerHeight;

      cornerSvg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      cornerSvg.style.height = h + 'px';

      const cxL = INSET + HALF;
      const cxR = w - INSET - HALF;
      const cyT = INSET + HALF;
      const cyB = h - INSET - HALF;

      setPlusGeometry(plus.TL, cxL, cyT);
      setPlusGeometry(plus.TR, cxR, cyT);
      setPlusGeometry(plus.BL, cxL, cyB);
      setPlusGeometry(plus.BR, cxR, cyB);

      if (!hasMouseMoved) {
        rotateAroundCenter(plus.TL, 0, cxL, cyT);
        rotateAroundCenter(plus.TR, 0, cxR, cyT);
        rotateAroundCenter(plus.BL, 0, cxL, cyB);
        rotateAroundCenter(plus.BR, 0, cxR, cyB);
        return;
      }

      const angDeg = (cx, cy) => (Math.atan2(cornerMouse.y - cy, cornerMouse.x - cx) * 180) / Math.PI;
      const rotTop = (cx, cy) => angDeg(cx, cy) - 90;
      const rotBot = (cx, cy) => angDeg(cx, cy) + 90;

      rotateAroundCenter(plus.TL, rotTop(cxL, cyT), cxL, cyT);
      rotateAroundCenter(plus.TR, rotTop(cxR, cyT), cxR, cyT);
      rotateAroundCenter(plus.BL, rotBot(cxL, cyB), cxL, cyB);
      rotateAroundCenter(plus.BR, rotBot(cxR, cyB), cxR, cyB);
    }

    window.addEventListener("resize", updateCornerMarks);
    
    // Handle mobile browser chrome changes (address bar show/hide)
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", updateCornerMarks);
    }
    
    updateCornerMarks();

    window.cornerRunning = true;
    
    (function cornerRAF() {
      if (!window.cornerRunning) return;
      updateCornerMarks();
      requestAnimationFrame(cornerRAF);
    })();

    // Stop corner animations when header not visible
    const visibilityObserver = new IntersectionObserver((entries) => {
      const visible = entries[0].isIntersecting;
      if (visible && !window.cornerRunning) {
        window.cornerRunning = true;
        (function cornerRAF() {
          if (!window.cornerRunning) return;
          updateCornerMarks();
          requestAnimationFrame(cornerRAF);
        })();
      } else if (!visible) {
        window.cornerRunning = false;
      }
    }, { threshold: 0.01 });
    visibilityObserver.observe(document.getElementById('header'));

    // ===== Down Arrow =====
    const arrow = document.getElementById("downArrow");
    const arrowLeft = document.getElementById("arrowLeft");
    const arrowRight = document.getElementById("arrowRight");

    function updateArrow() {
      const w = 40;
      const h = 20;

      const cx = w / 2;
      const cy = h; // bottom point (tip of V)

      // Left arm
      arrowLeft.setAttribute("x1", cx);
      arrowLeft.setAttribute("y1", cy);
      arrowLeft.setAttribute("x2", cx - 10);
      arrowLeft.setAttribute("y2", cy - 10);

      // Right arm
      arrowRight.setAttribute("x1", cx);
      arrowRight.setAttribute("y1", cy);
      arrowRight.setAttribute("x2", cx + 10);
      arrowRight.setAttribute("y2", cy - 10);
    }

    updateArrow();
    
    // Nav and arrow click handlers with custom smooth scroll
    // SCROLL SPEED CONFIG: duration in milliseconds (lower = faster)
    const SCROLL_DURATION = 1200; // 1200ms = 1.2 seconds
    
    function smoothScrollTo(targetElement, duration) {
      const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset;
      const startPosition = window.pageYOffset;
      const distance = targetPosition - startPosition;
      
      // Don't animate if already at target
      if (Math.abs(distance) < 1) return;
      
      let startTime = null;
      
      // Easing function - easeInOutCubic for smooth acceleration/deceleration
      function easeInOutCubic(t) {
        return t < 0.5 
          ? 4 * t * t * t 
          : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }
      
      function animation(currentTime) {
        if (startTime === null) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const progress = Math.min(timeElapsed / duration, 1);
        const easedProgress = easeInOutCubic(progress);
        
        window.scrollTo(0, startPosition + distance * easedProgress);
        
        if (timeElapsed < duration) {
          requestAnimationFrame(animation);
        }
      }
      
      requestAnimationFrame(animation);
    }
    
    document.querySelectorAll('.site-nav a').forEach(a => {
      a.addEventListener('click', (e) => {
        e.preventDefault();
        const href = a.getAttribute('href');
        let target;
        
        // Handle both #header and #home for the home link
        if (href === '#header' || href === '#home') {
          target = document.getElementById('header') || document.body;
          // Scroll to top of page
          smoothScrollTo(document.body, SCROLL_DURATION);
        } else {
          target = document.querySelector(href);
          if (target) {
            smoothScrollTo(target, SCROLL_DURATION);
          }
        }
      });
    });
    
    arrow.style.pointerEvents = "auto";
    arrow.style.cursor = "pointer";
    arrow.addEventListener("click", () => {
      smoothScrollTo(document.getElementById("about"), SCROLL_DURATION);
    });

    // Nav indicator animation
    const navHome = document.getElementById("navHome");
    const navAbout = document.getElementById("navAbout");
    const navWork = document.getElementById("navWork");
    const homeIndicator = navHome.querySelector(".nav-indicator");
    const aboutIndicator = navAbout.querySelector(".nav-indicator");
    const workIndicator = navWork.querySelector(".nav-indicator");
    const homeText = navHome.querySelector(".nav-text");
    const aboutText = navAbout.querySelector(".nav-text");
    const workText = navWork.querySelector(".nav-text");
    
    let homeFullWidth, aboutFullWidth, workFullWidth;
    
    function measureAndSetIndicators() {
      // Get each text's actual width + 2px (1px each side)
      homeFullWidth = homeText.getBoundingClientRect().width + 2;
      aboutFullWidth = aboutText.getBoundingClientRect().width + 2;
      workFullWidth = workText.getBoundingClientRect().width + 2;
      
      // Set initial state based on current scroll position
      updateNavIndicators();
    }
    
    function updateNavIndicators() {
      if (!homeFullWidth || !aboutFullWidth || !workFullWidth) return;
      
      const aboutSectionEl = document.getElementById("about");
      const workSectionEl = document.getElementById("work");
      if (!aboutSectionEl || !workSectionEl) return;
      
      const aboutRect = aboutSectionEl.getBoundingClientRect();
      const workRect = workSectionEl.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      
      // Calculate About progress (0 to 1)
      let aboutProgress = 0;
      if (aboutRect.top <= windowHeight && aboutRect.top >= 0) {
        aboutProgress = (windowHeight - aboutRect.top) / windowHeight;
      } else if (aboutRect.top < 0) {
        aboutProgress = 1;
      }
      aboutProgress = Math.max(0, Math.min(1, aboutProgress));
      
      // Calculate Work progress (0 to 1)
      let workProgress = 0;
      if (workRect.top <= windowHeight && workRect.top >= 0) {
        workProgress = (windowHeight - workRect.top) / windowHeight;
      } else if (workRect.top < 0) {
        workProgress = 1;
      }
      workProgress = Math.max(0, Math.min(1, workProgress));
      
      // Home indicator: full when on home, shrinks as About comes up
      homeIndicator.style.width = (homeFullWidth * (1 - aboutProgress)) + "px";
      
      // About indicator: grows as About comes up, shrinks as Work comes up
      if (workProgress > 0) {
        aboutIndicator.style.width = (aboutFullWidth * (1 - workProgress)) + "px";
      } else {
        aboutIndicator.style.width = (aboutFullWidth * aboutProgress) + "px";
      }
      
      // Work indicator: grows as Work comes up
      workIndicator.style.width = (workFullWidth * workProgress) + "px";
    }
    
    // Wait for fonts to load before measuring
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => {
        measureAndSetIndicators();
      });
    } else {
      // Fallback for browsers without font loading API
      window.addEventListener('load', measureAndSetIndicators);
    }
    
    // Also re-measure on resize in case font rendering changes
    window.addEventListener("resize", measureAndSetIndicators);
    
    // Update on scroll
    window.addEventListener("scroll", updateNavIndicators, { passive: true });

    // Pause corner animations during scroll
    let scrollTimeout;
    let isScrolling = false;
    
    window.addEventListener('scroll', () => {
      if (!isScrolling) {
        isScrolling = true;
        window.cornerRunning = false;
      }
      
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isScrolling = false;
        const headerRect = document.getElementById('header').getBoundingClientRect();
        if (headerRect.bottom > 0) {
          window.cornerRunning = true;
          (function restartCorner() {
            if (!window.cornerRunning) return;
            updateCornerMarks();
            requestAnimationFrame(restartCorner);
          })();
        }
      }, 100);
    }, { passive: true });
    // Size copyright logo to match "2026" width
    function sizeCopyrightLogo() {
      const copyrightEl = document.querySelector('.copyright');
      const spans = copyrightEl.querySelectorAll('span');
      const yearSpan = spans[1]; // "2026"
      const logo = copyrightEl.querySelector('.copyright-logo');
      
      const yearWidth = yearSpan.getBoundingClientRect().width;
      logo.style.width = yearWidth + 'px';
      logo.style.height = 'auto';
    }
    
    // Wait for fonts to load
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(sizeCopyrightLogo);
    } else {
      window.addEventListener('load', sizeCopyrightLogo);
    }
    
    window.addEventListener('resize', sizeCopyrightLogo);
  </script>
  
  <div id="headerSpacer"></div>

  <div id="pagesWrapper">
    <section id="about">
      <div class="about-container">
        <h1 class="about-title">About Me</h1>
        <div class="about-body">
          <p>I'm an ACD / Art Director based in Toronto with over a decade of full-time experience at agencies like FCB, Cossette, and The Hive. Over the last couple of years, I've been freelancing with shops including Anomaly, Sid Lee, 72andSunny Toronto, and others, and I'm currently working with Mekanism New York.</p>
          <p>I'm open to freelance opportunities and also considering full-time for the right fit.</p>
        </div>
      </div>
    </section>
    <div id="aboutPlaceholder" style="display:none; height:100vh;"></div>

    <section id="work">
      <div class="work-container">
        <h1 class="work-title">Work</h1>
        <div class="work-grid">
          <div class="work-item" style="background: #d9d9d9;"></div>
          <div class="work-item" style="background: #c9c9c9;"></div>
          <div class="work-item" style="background: #b9b9b9;"></div>
          <div class="work-item" style="background: #a9a9a9;"></div>
          <div class="work-item" style="background: #999999;"></div>
          <div class="work-item" style="background: #898989;"></div>
          <div class="work-item" style="background: #797979;"></div>
          <div class="work-item" style="background: #696969;"></div>
          <div class="work-item" style="background: #595959;"></div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // About and Work section fade-in based on scroll (runs after DOM ready)
    const aboutTitle = document.querySelector('.about-title');
    const aboutBody = document.querySelector('.about-body');
    const aboutSection = document.getElementById("about");
    const aboutContainer = document.querySelector('.about-container');
    
    const workTitle = document.querySelector('.work-title');
    const workGrid = document.querySelector('.work-grid');
    const workSection = document.getElementById("work");
    const workContainer = document.querySelector('.work-container');
    
    // Slide distance in pixels
    const slideDistance = 40;
    
    // Scale the about container based on viewport width
    function scaleAboutContent() {
      if (!aboutContainer) return;
      
      const viewportWidth = window.innerWidth;
      const margin = 55; // Same as menu left position
      // About section now uses CSS reflow instead of scaling
    }
    
    // Scale the work container based on viewport width - now handled by CSS
    function scaleWorkContent() {
      // Responsiveness now handled by CSS media queries
    }
    
    // Run on load and resize
    scaleWorkContent();
    window.addEventListener('resize', () => {
      scaleWorkContent();
    });
    
    function updateAboutFade() {
      if (!aboutTitle || !aboutBody || !aboutSection) return;
      
      const windowHeight = window.innerHeight;
      const placeholder = document.getElementById('aboutPlaceholder');
      
      // Get the scroll position where About should become fixed
      const headerSpacer = document.getElementById('headerSpacer');
      const headerSpacerBottom = headerSpacer.getBoundingClientRect().bottom;
      
      // About becomes fixed when headerSpacer bottom reaches top of viewport
      // Use a small threshold to prevent jitter at the exact transition point
      const shouldBeFixed = headerSpacerBottom <= 1;
      
      if (shouldBeFixed) {
        if (aboutSection.style.position !== 'fixed') {
          aboutSection.style.position = 'fixed';
          aboutSection.style.top = '0';
          aboutSection.style.left = '0';
          aboutSection.style.right = '0';
          aboutSection.style.bottom = '0';
          aboutSection.style.width = '100%';
          aboutSection.style.height = '100vh';
          placeholder.style.display = 'block';
        }
        
        // Fully visible - use full opaque gradient (not 'none' to avoid flicker)
        aboutTitle.style.webkitMaskImage = 'linear-gradient(to right, #000 0%, #000 100%)';
        aboutTitle.style.maskImage = 'linear-gradient(to right, #000 0%, #000 100%)';
        aboutTitle.style.transform = 'translateX(0)';
        
        aboutBody.style.webkitMaskImage = 'linear-gradient(to left, #000 0%, #000 100%)';
        aboutBody.style.maskImage = 'linear-gradient(to left, #000 0%, #000 100%)';
        aboutBody.style.transform = 'translateX(0)';
        return;
      } else {
        if (aboutSection.style.position !== 'relative') {
          aboutSection.style.position = 'relative';
          aboutSection.style.top = '';
          aboutSection.style.left = '';
          aboutSection.style.right = '';
          aboutSection.style.bottom = '';
          aboutSection.style.width = '';
          aboutSection.style.height = '';
          placeholder.style.display = 'none';
        }
      }
      
      // Get element positions
      const titleRect = aboutTitle.getBoundingClientRect();
      const bodyRect = aboutBody.getBoundingClientRect();
      
      // TITLE fade and slide
      // Element enters viewport when its top = windowHeight
      // Animation completes when headerSpacerBottom = 0
      // 
      // When title first enters: titleRect.top = windowHeight, headerSpacerBottom = some value X
      // When page at top: headerSpacerBottom = 0
      // 
      // The key insight: as we scroll, both titleRect.top and headerSpacerBottom decrease
      // We want progress to go from 0 to 1 as we scroll from "title entering" to "page at top"
      
      if (titleRect.top >= windowHeight) {
        // Title not yet in viewport
        aboutTitle.style.webkitMaskImage = 'linear-gradient(to right, transparent 0%, transparent 100%)';
        aboutTitle.style.maskImage = 'linear-gradient(to right, transparent 0%, transparent 100%)';
        aboutTitle.style.transform = `translateX(-${slideDistance}px)`;
      } else {
        // Title is in viewport
        // We need to track progress from when title FIRST entered viewport to when page hits top
        // 
        // When title first enters: titleRect.top = windowHeight, and headerSpacerBottom = X
        // When page hits top: headerSpacerBottom = 0
        //
        // The title enters the viewport when headerSpacerBottom is still positive
        // At that moment, headerSpacerBottom tells us how much scroll is left until page hits top
        //
        // Progress should be based on: how much of the remaining scroll have we done?
        // Remaining scroll at entry = headerSpacerBottom when title first entered
        // Current remaining scroll = headerSpacerBottom now
        
        // Since the content is centered, title enters when about section enters
        // About section enters when headerSpacerBottom < windowHeight
        // So: entry point is headerSpacerBottom = windowHeight
        // End point is headerSpacerBottom = 0
        
        // But title enters later than page edge - need to account for title's position within page
        // Title is roughly centered, so it enters when headerSpacerBottom ≈ windowHeight/2
        
        // Simple approach: progress based on how far headerSpacerBottom has gone from windowHeight to 0
        // Clamped to start when title is actually in viewport
        
        let progress = 1 - (headerSpacerBottom / windowHeight);
        progress = Math.max(0, Math.min(1, progress));
        
        // Gradient reveal: constant width gradient that travels completely across
        // Gradient starts fully off-screen left, ends fully off-screen right
        const fadeWidth = 60;
        // Start further back so less content shows initially
        const revealPoint = -fadeWidth - 80 + (progress * (100 + fadeWidth + 80));
        
        const titleMask = `linear-gradient(to right, #000 0%, #000 ${revealPoint}%, transparent ${revealPoint + fadeWidth}%, transparent 100%)`;
        aboutTitle.style.webkitMaskImage = titleMask;
        aboutTitle.style.maskImage = titleMask;
        
        // Ensure transform is exactly 0 when progress is 1 to avoid jitter
        const titleSlide = progress >= 1 ? 0 : -slideDistance + (progress * slideDistance);
        aboutTitle.style.transform = `translateX(${titleSlide}px)`;
      }
      
      // BODY fade and slide
      if (bodyRect.top >= windowHeight) {
        // Body not yet in viewport
        aboutBody.style.webkitMaskImage = 'linear-gradient(to left, transparent 0%, transparent 100%)';
        aboutBody.style.maskImage = 'linear-gradient(to left, transparent 0%, transparent 100%)';
        aboutBody.style.transform = `translateX(${slideDistance}px)`;
      } else {
        // Body is in viewport - use same progress as title but can offset slightly if desired
        let progress = 1 - (headerSpacerBottom / windowHeight);
        progress = Math.max(0, Math.min(1, progress));
        
        // Gradient reveal from right to left
        // Gradient reveal: constant width gradient that travels completely across
        const fadeWidth = 60;
        // Start further back so less content shows initially
        const revealPoint = -fadeWidth - 80 + (progress * (100 + fadeWidth + 80));
        
        const bodyMask = `linear-gradient(to left, #000 0%, #000 ${revealPoint}%, transparent ${revealPoint + fadeWidth}%, transparent 100%)`;
        aboutBody.style.webkitMaskImage = bodyMask;
        aboutBody.style.maskImage = bodyMask;
        
        // Ensure transform is exactly 0 when progress is 1 to avoid jitter
        const bodySlide = progress >= 1 ? 0 : slideDistance - (progress * slideDistance);
        aboutBody.style.transform = `translateX(${bodySlide}px)`;
      }
    }
    
    // Update on scroll
    window.addEventListener("scroll", updateAboutFade, { passive: true });
    updateAboutFade();
    
    // Work section fade-in
    function updateWorkFade() {
      if (!workTitle || !workGrid || !workSection) return;
      
      const windowHeight = window.innerHeight;
      const workRect = workSection.getBoundingClientRect();
      const titleRect = workTitle.getBoundingClientRect();
      const gridRect = workGrid.getBoundingClientRect();
      
      // Check if Work section is fully visible (top at or above viewport top)
      const workFullyOpen = workRect.top <= 0;
      
      if (workFullyOpen) {
        // Fully visible - use full opaque gradient (not 'none' to avoid flicker)
        workTitle.style.webkitMaskImage = 'linear-gradient(to right, #000 0%, #000 100%)';
        workTitle.style.maskImage = 'linear-gradient(to right, #000 0%, #000 100%)';
        workTitle.style.transform = 'translateX(0)';
        
        workGrid.style.opacity = '1';
        return;
      }
      
      // Calculate progress based on Work section position
      // When workRect.top = windowHeight, progress = 0 (Work just entering)
      // When workRect.top = 0, progress = 1 (Work fully open)
      let progress = 1 - (workRect.top / windowHeight);
      progress = Math.max(0, Math.min(1, progress));
      
      // TITLE fade and slide
      if (titleRect.top >= windowHeight) {
        workTitle.style.webkitMaskImage = 'linear-gradient(to right, transparent 0%, transparent 100%)';
        workTitle.style.maskImage = 'linear-gradient(to right, transparent 0%, transparent 100%)';
        workTitle.style.transform = `translateX(-${slideDistance}px)`;
      } else {
        // Gradient reveal: constant width gradient that travels completely across
        const fadeWidth = 60;
        // Start further back so less content shows initially
        const revealPoint = -fadeWidth - 80 + (progress * (100 + fadeWidth + 80));
        
        const titleMask = `linear-gradient(to right, #000 0%, #000 ${revealPoint}%, transparent ${revealPoint + fadeWidth}%, transparent 100%)`;
        workTitle.style.webkitMaskImage = titleMask;
        workTitle.style.maskImage = titleMask;
        
        const titleSlide = -slideDistance + (progress * slideDistance);
        workTitle.style.transform = `translateX(${titleSlide}px)`;
      }
      
      // GRID fade only (no vertical movement)
      if (gridRect.top >= windowHeight) {
        workGrid.style.opacity = '0';
      } else {
        const gridPixelsInView = windowHeight - gridRect.top;
        const totalDistance = gridPixelsInView + workRect.top;
        
        let gridProgress = totalDistance > 0 ? gridPixelsInView / totalDistance : 1;
        gridProgress = Math.max(0, Math.min(1, gridProgress));
        
        workGrid.style.opacity = gridProgress;
      }
    }
    
    window.addEventListener("scroll", updateWorkFade, { passive: true });
    updateWorkFade();
  </script>
</body>
</html>
